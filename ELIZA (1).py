# Author: Elias Rosenberg
# Date: April 5
# Purpose: Create an ELIZA function that uses regex to take input sentences in spanish
# and flips them back to the user as a question to continue a conversation

import sys
import re

global userInput


# =====================================================================================
# Function:     compileRegEx
#
# Input:        regExInput (a string with a regular expression)
# Output:       A regular expression object (https://docs.python.org/3/library/re.html#re.compile)
#               which can be used to perform searches
# Description:  The function takes a regular expression and compiles it. It uses the
#               re.IGNORECASE flag, so that it will match the expression ignoring
#               upper and lowercase.
# =====================================================================================

def compileRegEx(regExInput):
    return re.compile(regExInput, re.IGNORECASE)


# =====================================================================================
# Function:     eliza
#
# Input:        userInput (a string with a phrase in the English language)
# Output:       reply (a string with a response, in English, generated by the function)
# Description:  The function uses regular expressions to read input from the user
#               and produce a response using natural language (English). Right now the
#               function is just a template, so it can only respond to the question
#               "What is your name?".
# =====================================================================================

# Part I

def eliza(userInput):
    reply = "Cuéntame más..."  # reply if user input doesn't match any of the regex.

    # regular expressions
    reName = compileRegEx("(Mi|Me) (nombre|llamo) (es)?(.+)\.?")  # initial greeting
    reAdj = compileRegEx("(.+)? ?(Estoy|estoy) (.+)\.?")  # feeling
    reChar = compileRegEx("(.+)? ?(soy|Soy) (.+)\.?")  # characteristics
    reFam = compileRegEx("(.+)(mi) (mamá|papá) (.+)\.?")  # family
    reModal = compileRegEx("(.+)?(Quier|quier|Deb|Pued|pued)o (.+er|.+ar|ir)?(me)?(.+)\.?")  # Modal verbs
    reThought = compileRegEx("(.+)?(Piens|esper)o (.+)\.?")  # hopes and thoughts
    reAlways = compileRegEx("(.+) siempre (.+)\.?")  # specific examples
    reInsult = compileRegEx("(.+) (idiota|¡estúpida!|estúpida)\W?")  # handling insults

    # initial greetings
    if (reName.match(userInput)):
        stringName = reName.search(userInput)
        reply = "Hola, " + stringName.group(4).strip(".") + ". ¿Cómo estás?"

    # State of mindand adverbs(verb estoy‘I am’ >estás‘you are’)
    if (reAdj.match(userInput)):
        stringAdj = reAdj.search(userInput)
        negation = "no"
        if negation in userInput:
            reply = "¿Porqué no estás " + stringAdj.group(3).strip(".") + "?"
        else:
            reply = "¿Porqué estás " + stringAdj.group(3).strip(".") + "?"

    # Characteristics of a person(verb soy‘I am’). Notice that the sentence can be preceded by a phrase and
    # then the word que “that”.
    if (reChar.match(userInput)):
        stringChar = reChar.search(userInput)
        negation = "no"
        if negation in userInput:
            reply = "¿Porqué no eres " + stringChar.group(3).strip(".") + "?"
        else:
            reply = "¿Porqué eres " + stringChar.group(3).strip(".") + "?"

    # About your family
    if (reFam.match(userInput)):
        stringFam = reFam.search(userInput)
        reply = "Cuéntame más de tu " + stringFam.group(3).strip(".") + "."

    # Handling modal verbs(e.g. poder‘can’: pued+o‘I can’ >pued+es ‘you can’)and clitics (V+me>V+te).
    # Notice that the sentence can be preceded by a phrase and then the word que“that”.
    if (reModal.match(userInput)):
        stringModal = reModal.search(userInput)
        negation = "no" and "No"
        reflexive = "rme"  # verbs ending in rme must be changed to rte, while infinitives stay the same.
        if reflexive in userInput:
            if negation in userInput:
                reply = "¿Porqué no " + stringModal.group(2) + "es " + stringModal.group(3) + "te" + stringModal.group(
                    5).strip(".") + "?"
            else:
                reply = "¿Porqué " + stringModal.group(2) + "es " + stringModal.group(3) + "te" + stringModal.group(
                    5).strip(".") + "?"
        else:
            if negation in userInput:
                reply = "¿Porqué no " + stringModal.group(2) + "es " + stringModal.group(3) + stringModal.group(
                    5).strip(".") + "?"
            else:
                reply = "¿Porqué " + stringModal.group(2) + "es " + stringModal.group(3) + stringModal.group(5).strip(
                    ".") + "?"

    # Thoughts and hopes(e.g. pensar‘I think’: piens+o‘I think’ >piens+as‘you think’)
    if (reThought.match(userInput)):
        stringThought = reThought.search(userInput)
        negation = "no"
        if negation in userInput:
            reply = "¿Porqué no " + stringThought.group(2) + "as" + " eso?"
        else:
            reply = "¿Porqué " + stringThought.group(2) + "as" + " eso?"

    # Asking for specific examples
    if (reAlways.match(userInput)):
        stringAlways = reAlways.search(userInput)
        reply = ("¿Puedes darme un ejemplo específico?")

    # Handling insults
    if (reInsult.match(userInput)):
        stringInsult = reInsult.search(userInput)
        reply = "¡Hey, sin insultos! Cálmate y cuéntame más."

    return print(reply)  # prints out the most recent form of "reply"


# =====================================================================================

if (len(sys.argv) < 2):
    print("Es un placer conocerte! Cuál es su nombre.")  # starting phrase

while True:  # infinite loop to keep running user input through the function
    userInput = input()  # taking in the user response
    eliza(userInput)
    if (userInput == "detener"):  # ending the program
        quit()

# Part II
# What changes would you make to the program so that it can carry out a more human-like conversation? Please make
# three suggestions for how to improve the program  and  find  a  section  of  the
# Jurafsky  and  Martin  textbook  that  can  help  you  implement  those changes. Mention those sections explicitly.
# The answer should be at least 200 words long.

# There are more than three things we could do to make the conversation more human-like, but here are three options
# from the textbook in sections 2.3-2.5. Language is ever-evolving, and slang is an important part of making any NLP
# matching seem less robotic. Section 2.3 talks about the importance of choosing the right corpora to train your
# algorithms. Using Brown's corpora from the 1960's might not interpret modern slang terms like the word "lit" that
# everyone knows now. If there was a corpora of sentences that included spanish slang, we could incorporate those
# into our regex responses to make our responses sound less robotic. Lemmatization from 2.4 could improve our verb
# tracking. If we could separate verbs from their conjugations by taking their lemmas, we can find verbs without
# considering the affixes, which I had to do for the reflexive verbs. Section 2.5 discusses the minimum edit distance
# algorithm, which would be so awesome to add to allow some more variability in spelling. If things are spelled
# correctly, there's a change my specific regex wouldn't pick up the pattern. A real human can recognize a spelling
# error and usually fill in the gaps. This fourth solution wasn't mentioned in the text book, but professor Rolando
# mentioned in slack that probability distributions can be used to distinguish between sentences that fit two regexes.
# For example, if someone wrote "I should visit my mother," it could fit both the family regex and the modal verbs
# regex. If we had an algorithm to see what was more probable from the user, we code produce a more coherent response.
